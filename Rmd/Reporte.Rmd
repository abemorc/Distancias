
---
title: "Distancia recorrida Incilius spiculatus"
date: "`r Sys.Date()`"
author: "abe"
output:
  rmdformats::robobook:
    highlight: kate
    toc_depth: 2

---

```{r setup, include=FALSE}
library(tidyverse)
library(knitr)
library(rmdformats)
library(DT)
library(kableExtra)
library(sjPlot)
library(here)

#library(dplyr)

## Global options
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	prompt = TRUE
)

```


```{r include=FALSE}
#funcion para cambiar colores
colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color,
      x)
  } else x
}

```


```{r include=FALSE}
texto <- "Preparar los datos"
```
# `r colorize(texto, "darkseagreen")`

> 

##  Importar dataframe
Importaremos los datos del archivo excel que nos envio el **midgardo** asegurandonos de que ya estamos en el directorio de trabajo adecuado
```{r}
#importar datos
df1 <- readxl::read_excel(here("Data", "spicu2.xlsx"), sheet = "in")
```

Veamos como estan los datos para poder organizarlos
```{r}
df1
```

Con la funcion `str()` podemos ver la estructura de un dataframe y la informacion relevante de este
```{r}
str(df1)
```

Veamos la base de datos completa  
```{r echo=FALSE}
datatable(df1)
```


Con esto ya sabemos de que forma organizarnos, asi que para un facil acceso a los
nombres de las variables reemplazaremos los espacios por giones, asi evitamos que
salgan comillas al seleccionarlas mediante $

```{r}
vremove <- c(" ")
vreplace <- c("_")

names(df1) <- gsub(vremove, vreplace, names(df1))
names(df1)
```

## Seleccion variables

Ya con los nombres "corregidos" vamos a seleccionar las variables que nos interesan,
en este caso las que nos indicaron 
```{r}
#seleccionar variables que interesan al tronco 
dfdatos <- df1 %>% 
  select(Sitio, Sexo, Distancia24hrs, Distancia_total_reccorida, Temporada,
         NDVI_SMO:Altura_de_arbol)

str(dfdatos)
```

Al importar archivos es comun que no tengan el tipo de dato correcto para poder realizar
operaciones sobre ellos, por lo que es necesario asegurarse de que cada variable tenga el tipo correcto

Tambien crearemos variables dummy para las variables categricas

```{r include=FALSE}
dfdatosori <- dfdatos
```

## Construir variables dummy
```{r}
dfdatos <- dfdatos %>% 
  mutate(Distancia24hrs = as.numeric(Distancia24hrs),
         Sitio_cons = ifelse(Sitio == "Conservado", 1, 0),
         Sexo_macho = ifelse(Sexo == "Macho", 1, 0),
         Sex_hembra = ifelse(Sexo == "Hembra", 1, 0),
         Temporada_seca = ifelse(Temporada == "Secas", 1, 0)) %>% 
  select(Distancia24hrs, Distancia_total_reccorida, NDVI_SMO:Altura_de_arbol,
         Sitio_cons:Temporada_seca)

#verificar que todo este correcto
str(dfdatos)
```

Veamos como quedaron nuestro datos ya preparados para los analisis, para este caso son pocas obsevaciones y pocas 
variables, pero suponiendo que fuesen mas añadiremos unos filtros para poder facilmente
realizar una exploracion de los datos mediante la tabla.
```{r echo=FALSE}
datatable(dfdatos, filter = "bottom")
```

>Se realizara el analisis para la distancia por dia `$Distancia24hrs` y para la distancia
total recorrida `Distancia_total_recorrida`

<!-- aqui empieza lo chido -->


```{r include=FALSE}
texto <- "Analisis distancia por día recorrida"
```
# `r colorize(texto, "darkseagreen")`

Construiremos el dataframe que utilizaremos para este analisis de distancia por dia
```{r}
dfdatos1 <- dfdatos[,c(1, 3:10, 12, 13)]
```

```{r echo=FALSE}
datatable(dfdatos1, style = "bootstrap4")
```

Veamos una primera impresion de la distribucion de los datos
```{r}
hist(x = dfdatos1$Distancia24hrs, breaks = 7, xlab = "Distancia recorrida", main = "Distribucion datos 24hrs")
```

## Estandarización

Para el analisis de correlacion no es necesario estandarizar las variables, sin embargo es comun
hacerlo pues se puede comparar mas facilmente las variables al estar poder medirlas en terminos de 
desviaciones estandar

Crearemos una funcion que a cada valor reste la media de su conjunto y el resultado
lo divida entre la desviacion estandar del mismo

```{r}
Estandarizar <- function(x){
  (x-mean(x, na.rm = T))/sd(x, na.rm = T)
}
```

Y aplicaremos dicha funcion a todas las variables numericas guardandolo en otro datframe,
porque los datos originales los utilizaremos al final
```{r}
dfdatos1Est <- dfdatos1
dfdatos1Est[c(2:8)] <- apply(X = dfdatos1Est[c(2:8)], MARGIN = 2, FUN = Estandarizar)
dfdatos1Est
```

Comprobaremos que su media es igual a cero y su desviación estandar a uno

```{r}
apply(X = dfdatos1Est[c(2:8)], MARGIN = 2, FUN = mean)
apply(X = dfdatos1Est[c(2:8)], MARGIN = 2, FUN = sd)
```

> Con los datos ya estandarizados y las variables dummy creadas podemos porceder a realizar 
los analisis de correlacion

## Correlacion

### Cuantitativas

Nos interesa saber que variables afectan mas a la distancia recorrida asi que podriamos 
realizar un test de correlacion de cada variable en nuestro conjunto de datos respecto a la distancia.
Algo asi:
```{r}
cor(dfdatos1Est$Distancia24hrs, dfdatos1Est$EVI_SMO, use ="complete.obs", method = "spearman")
```

Pero seria mas tardado, asi que haremos una matriz de correlaciones para obtener todas de una vez 
ademas de identificar si algunas de las variables estan relacionadas entre si  

Usaremos el coeficiente de correlacion de spearman ya que nos permite evaluar una
relacion monotona entre dos variables continuas, es decir cuando las variables cambian 
al mismo tiempo pero no necesariamentea un ritmo constante a diferencia del coeficiente de pearson que solo evalua 
una relacion lineal entre las variables.

```{r}
correlaciones <- cor(dfdatos1Est[c(1:8)], use ="complete.obs", method = "spearman")
correlaciones

```

Calcularemos la correlacion en los datos sin estandarizar, solo para comprobar
que los resultados no se ven afectados

```{r}
correlaciones1 <- cor(dfdatos1[c(1:8)], use ="complete.obs", method = "spearman")
correlaciones1
```

Y solo por curiosidad lo haremos mediante el metodo de pearson
```{r}
corrpearson <- cor(dfdatos1Est[c(1:8)], use ="complete.obs", method = "pearson")
corrpearson
```

Con esto vemos que aunque los resultados no son iguales, si son muy similares en cuanto al gardo de correlacion

>

Pongamos bonitos los resultados (Spearman)

```{r}
tab_corr(dfdatos1Est[c(1:8)], corr.method = "spearman")

tab_df(as.data.frame(correlaciones), title = "Correlaciones", 
       footnote = "Calculadas por el metodo de Spearman", show.footnote = T, 
       digits = 3, show.rownames = T)

correlaciones %>%
    kbl(caption = "CORRELACIONES", digits = 3, align = "c") %>%
  kable_classic_2(full_width = F) %>% 
  footnote(general = "Calculado por el método de Spearman")
```
En la tabla podemos observar lo siguiente:  
**NDVI_SMO** y **NDWI_SMO** presentan una relacion inversa muy fuerte.  
**NDVI_SMO** y **NDMI_SMO** presentan una relacion moderada.  
**EVI_SMO** y **LST_SMO** presentan una relacion fuerte.  
**NDWI_SMO** y **NDMI_SMO** presentan una relacion inversa moderada.  

En cuanto a la **Distancia24hrs** (la variable que nos es de interes), 
vemos que **EVI_SMO** y **LST_SMO** serian las que presentan una 
ligera relacion inversa

Ordenemos los resultados de forma descendente en base a su valor absoluto
tomando unicamente la distancia y pongamos los resultados con una bonita 
presentacion
```{r}
relaciones <- as.data.frame(correlaciones)
relaciones[order(relaciones$Distancia24hrs),]
rel <- relaciones[order(abs(relaciones$Distancia24hrs), decreasing = T), 1, drop = F]
rel
```
```{r echo=FALSE}
rel %>%
    kbl(caption = "ORDEN DE CORRELACION RESPECTO A LA DISTANCIA", digits = 3, align = "c") %>%
  kable_classic_2(full_width = F) %>% 
  footnote(general = "Calculado por el método de Spearman")
```


Para estar seguros de los resultados anteriores  calcularemos su grado de significancia

```{r}
probcor <- Hmisc::rcorr(as.matrix(dfdatos1Est[c(1:8)]), type = "spearman")
probcor$P
```

Y tambien los ordenaremos respecto a la distancia
```{r}
probcor1 <- as.data.frame(probcor$P)
probcor1[order(probcor1$Distancia24hrs), 1 , drop = F]
probcor1 <- probcor1[order(probcor1$Distancia24hrs), 1 , drop = F]
probcor1
```

Aquellas que tengan un p_value menor a 0.05 son aquellas que se puede afirmar que 
presentan una relacion 

Pongamos presentables los resultados
```{r echo=FALSE}
probcor$P %>%
    kbl(caption = "SIGNIFICANCIA DE LAS CORRELACIONES", digits = 3, align = "c") %>%
  kable_classic_2(full_width = F) %>% 
  footnote(general = "Calculado por el método de Spearman")

probcor1 %>%
    kbl(caption = "ORDEN DE SIGNIFICANCIA RESPECTO A LA DISTANCIA", digits = 3, align = "c") %>%
  kable_classic_2(full_width = F) %>% 
  footnote(general = "Calculado por el método de Spearman")

```
Aquellas que tengan un p_value menor a 0.05 son aquellas que se puede afirmar que 
presentan una relacion 

Con la informacion de las tablas anterior podemos ver cuales son las variables que tienen mayor
relacion con la distancia recorrida asi como entre ellas

Grafiquemos los resultados obtenidos

```{r}
pairs(dfdatos1Est[c(1:8)])
PerformanceAnalytics::chart.Correlation(dfdatos1Est[c(1:8)], histogram = T,
                                        method = "spearman")
```

Pongamos todo en una sola grafica 
```{r}
psych::pairs.panels(dfdatos1Est[c(1:8)], method = "spearman", stars = TRUE,  
             hist.col = 4, smooth = TRUE, scale = F, density = TRUE,
             pch = 21, lm = F, jiggle = T, ci = TRUE)
```

> Con esto ya tenemos claro cuales variables cuantitativas influyen mas en la distancia

### Categoricas

Veamos visualmente como estan distribuidas las variables categoricas

```{r}
boxplot(formula = as.numeric(Distancia24hrs) ~ Sitio, data = na.omit(dfdatosori),
        na.action=na.pass)
boxplot(formula = as.numeric(Distancia24hrs) ~ Sexo, data = na.omit(dfdatosori),
        na.action=na.pass)
boxplot(formula = as.numeric(Distancia24hrs) ~ Temporada, data = na.omit(dfdatosori),
        na.action=na.pass)
```

Podemos observar que el `Sitio perturbado`, `Sexo_hembra` y `Temporada_lluvias` presentan
mayores distancias que su contraparte

Sin embargo eso no nos dice cual de las tres influya mas en la distanca, para determinarlo
usaremos un metodo llamado point biserial correlation, que nos permite calcular la correlacion
entre una variable categorica y una cuantitativa.
```{r}
relacionSexo <- cor.test(dfdatos1Est$Sex_hembra, dfdatos1Est$Distancia24hrs) 
relacionSitio <- cor.test(dfdatos1Est$Sitio_cons, dfdatos1Est$Distancia24hrs)
relacionTemporada <- cor.test(dfdatos1Est$Temporada_seca, dfdatos1Est$Distancia24hrs)

print(relacionSexo)
print(relacionSitio)
print(relacionTemporada)
```

Con esto comprobamos lo que observamos en los boxplot:  
**Sexo_hembra** tiene relacion positiva fuerte  
**Sitio_cons** tiene relacion inversa debil  
**Temporada_seca** tiene relacion inversa moderada  

Las ordenaremos de acuerdo a su grado de significancia
```{r}
v <- c(relacionSexo$p.value, relacionSitio$p.value, relacionTemporada$p.value)
names(v) <- c("Sexo", "Sitio", "Temporada")
v <- as.data.frame(v[order(v)])
names(v) <- "p_value"
v
```
```{r echo=FALSE}
v %>%
    kbl(caption = "ORDEN DE SIGNIFICANCIA"
        , digits = 3, align = "c") %>%
    kable_classic_2(full_width = F) %>% 
    footnote(general = "Point biserial correlation")

```

Graficando los resultados
```{r}
dfdatos1Est1 <- na.omit(dfdatos1Est)
dfdatos1Est1
cor(dfdatos1Est1[9:11])
corrplot::corrplot(cor(dfdatos1Est1[c(1, 9:11)]))

```

Basandonos en el *p_value* haremos una lista con el orden de importancia de
nuestro dataset para la variable `Distancia24hrs` con su respectiva tabla
```{r}
names(v) <- names(probcor1)
str(rbind(v,probcor1))
importancia_variables <- rbind(probcor1, v)
importancia_variables <-  importancia_variables[order(importancia_variables), ,
                                                drop = F]

importancia_variables

```
```{r echo=FALSE}
a <- length(importancia_variables$Distancia24hrs)
importancia_variables[-a, ,drop = F] %>%
    kbl(caption = "ORDEN DE SIGNIFICANCIA RESPECTO A LA DISTANCIA POR DIA"
        , digits = 3, align = "c") %>%
    kable_classic_2(full_width = F) %>% 
    footnote(general = "Valores redondeados")

```
> 


## Regresion lineal simple

aqui va tu chimuelo
intentar ajustar un modelo lineal 
## Regresion lineal generalizada (GLM)



```{r include=FALSE}
texto <- "Analisis distancia total"
```
# `r colorize(texto, "darkseagreen")`


You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

